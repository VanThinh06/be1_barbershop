// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: barber_roles.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createBarberRoles = `-- name: CreateBarberRoles :one
INSERT INTO "BarberRoles" (
    barber_id,
    barbershop_id,
    role_id
  )
VALUES (
    $1,
    $2,
    $3
  )
RETURNING id, barber_id, barbershop_id, role_id, create_at, update_at
`

type CreateBarberRolesParams struct {
	BarberID     uuid.UUID `json:"barber_id"`
	BarbershopID uuid.UUID `json:"barbershop_id"`
	RoleID       int32     `json:"role_id"`
}

func (q *Queries) CreateBarberRoles(ctx context.Context, arg CreateBarberRolesParams) (BarberRole, error) {
	row := q.db.QueryRowContext(ctx, createBarberRoles, arg.BarberID, arg.BarbershopID, arg.RoleID)
	var i BarberRole
	err := row.Scan(
		&i.ID,
		&i.BarberID,
		&i.BarbershopID,
		&i.RoleID,
		&i.CreateAt,
		&i.UpdateAt,
	)
	return i, err
}

const deleteBarberRoles = `-- name: DeleteBarberRoles :exec
DELETE FROM "BarberRoles"
WHERE "id" = $1
`

func (q *Queries) DeleteBarberRoles(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteBarberRoles, id)
	return err
}

const getBarberRoles = `-- name: GetBarberRoles :one
SELECT id, barber_id, barbershop_id, role_id, create_at, update_at
FROM "BarberRoles"
WHERE "BarberRoles"."barber_id" = $1 AND "BarberRoles"."barbershop_id" = $2
LIMIT 1
`

type GetBarberRolesParams struct {
	BarberID     uuid.UUID `json:"barber_id"`
	BarbershopID uuid.UUID `json:"barbershop_id"`
}

func (q *Queries) GetBarberRoles(ctx context.Context, arg GetBarberRolesParams) (BarberRole, error) {
	row := q.db.QueryRowContext(ctx, getBarberRoles, arg.BarberID, arg.BarbershopID)
	var i BarberRole
	err := row.Scan(
		&i.ID,
		&i.BarberID,
		&i.BarbershopID,
		&i.RoleID,
		&i.CreateAt,
		&i.UpdateAt,
	)
	return i, err
}

const listBarbersRoles = `-- name: ListBarbersRoles :many
SELECT "BarberRoles".id, barber_id, barbershop_id, role_id, "BarberRoles".create_at, "BarberRoles".update_at, "Roles".id, name, "Roles".create_at, "Roles".update_at
FROM "BarberRoles"
JOIN "Roles" ON "BarberRoles"."role_id" = "Roles"."id"
WHERE "BarberRoles"."barbershop_id" = $1
ORDER BY "Roles"."id"
`

type ListBarbersRolesRow struct {
	ID           uuid.UUID `json:"id"`
	BarberID     uuid.UUID `json:"barber_id"`
	BarbershopID uuid.UUID `json:"barbershop_id"`
	RoleID       int32     `json:"role_id"`
	CreateAt     time.Time `json:"create_at"`
	UpdateAt     time.Time `json:"update_at"`
	ID_2         int32     `json:"id_2"`
	Name         string    `json:"name"`
	CreateAt_2   time.Time `json:"create_at_2"`
	UpdateAt_2   time.Time `json:"update_at_2"`
}

func (q *Queries) ListBarbersRoles(ctx context.Context, barbershopID uuid.UUID) ([]ListBarbersRolesRow, error) {
	rows, err := q.db.QueryContext(ctx, listBarbersRoles, barbershopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBarbersRolesRow{}
	for rows.Next() {
		var i ListBarbersRolesRow
		if err := rows.Scan(
			&i.ID,
			&i.BarberID,
			&i.BarbershopID,
			&i.RoleID,
			&i.CreateAt,
			&i.UpdateAt,
			&i.ID_2,
			&i.Name,
			&i.CreateAt_2,
			&i.UpdateAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBarberRoles = `-- name: UpdateBarberRoles :one
UPDATE "BarberRoles"
SET "role_id" = $1,
    "update_at" = NOW()
WHERE "id" = $2
RETURNING id, barber_id, barbershop_id, role_id, create_at, update_at
`

type UpdateBarberRolesParams struct {
	RoleID int32     `json:"role_id"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) UpdateBarberRoles(ctx context.Context, arg UpdateBarberRolesParams) (BarberRole, error) {
	row := q.db.QueryRowContext(ctx, updateBarberRoles, arg.RoleID, arg.ID)
	var i BarberRole
	err := row.Scan(
		&i.ID,
		&i.BarberID,
		&i.BarbershopID,
		&i.RoleID,
		&i.CreateAt,
		&i.UpdateAt,
	)
	return i, err
}
