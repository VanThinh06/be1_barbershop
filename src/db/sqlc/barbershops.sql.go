// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: barbershops.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteBarberShopById = `-- name: DeleteBarberShopById :exec
DELETE FROM "BarberShops"
WHERE id = $1
`

func (q *Queries) DeleteBarberShopById(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteBarberShopById, id)
	return err
}

const getBarberShopById = `-- name: GetBarberShopById :one
SELECT id, barber_shop_chain_id, name, province_name, district_name, ward_name, specific_location, phone, email, website_url, coordinates, avatar_url, cover_photo_url, facade_photo_url, representative_name, citizen_id, representative_phone, representative_email, representative_phone_other, start_time_monday, end_time_monday, start_time_tuesday, end_time_tuesday, start_time_wednesday, end_time_wednesday, start_time_thursday, end_time_thursday, start_time_friday, end_time_friday, start_time_saturday, end_time_saturday, start_time_sunday, end_time_sunday, interval_scheduler, is_main_branch, is_reputation, is_verified, create_at
FROM "view_barber_shops" bs
WHERE bs.id = $1
`

func (q *Queries) GetBarberShopById(ctx context.Context, id uuid.UUID) (ViewBarberShop, error) {
	row := q.db.QueryRow(ctx, getBarberShopById, id)
	var i ViewBarberShop
	err := row.Scan(
		&i.ID,
		&i.BarberShopChainID,
		&i.Name,
		&i.ProvinceName,
		&i.DistrictName,
		&i.WardName,
		&i.SpecificLocation,
		&i.Phone,
		&i.Email,
		&i.WebsiteUrl,
		&i.Coordinates,
		&i.AvatarUrl,
		&i.CoverPhotoUrl,
		&i.FacadePhotoUrl,
		&i.RepresentativeName,
		&i.CitizenID,
		&i.RepresentativePhone,
		&i.RepresentativeEmail,
		&i.RepresentativePhoneOther,
		&i.StartTimeMonday,
		&i.EndTimeMonday,
		&i.StartTimeTuesday,
		&i.EndTimeTuesday,
		&i.StartTimeWednesday,
		&i.EndTimeWednesday,
		&i.StartTimeThursday,
		&i.EndTimeThursday,
		&i.StartTimeFriday,
		&i.EndTimeFriday,
		&i.StartTimeSaturday,
		&i.EndTimeSaturday,
		&i.StartTimeSunday,
		&i.EndTimeSunday,
		&i.IntervalScheduler,
		&i.IsMainBranch,
		&i.IsReputation,
		&i.IsVerified,
		&i.CreateAt,
	)
	return i, err
}

const insertBarberShop = `-- name: InsertBarberShop :one
INSERT INTO "BarberShops" (
    barber_shop_chain_id,
    name,
    province_id,
    district_id,
    ward_id,
    specific_location,
    phone,
    email,
    website_url,
    avatar_url,
    cover_photo_url,
    facade_photo_url,
    representative_name,
    citizen_id,
    representative_phone,
    representative_email,
    representative_phone_other,
    start_time_monday,
    end_time_monday,
    start_time_tuesday,
    end_time_tuesday,
    start_time_wednesday,
    end_time_wednesday,
    start_time_thursday,
    end_time_thursday,
    start_time_friday,
    end_time_friday,
    start_time_saturday,
    end_time_saturday,
    start_time_sunday,
    end_time_sunday,
    interval_scheduler,
    coordinates
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32,
      ST_GeographyFromText('POINT(' || $33::float8 || ' ' || $34::float8 || ')')
) RETURNING id, barber_shop_chain_id, name, province_id, district_id, ward_id, specific_location, phone, email, website_url, coordinates, avatar_url, cover_photo_url, facade_photo_url, representative_name, citizen_id, representative_phone, representative_email, representative_phone_other, start_time_monday, end_time_monday, start_time_tuesday, end_time_tuesday, start_time_wednesday, end_time_wednesday, start_time_thursday, end_time_thursday, start_time_friday, end_time_friday, start_time_saturday, end_time_saturday, start_time_sunday, end_time_sunday, interval_scheduler, is_main_branch, is_reputation, is_verified, create_at
`

type InsertBarberShopParams struct {
	BarberShopChainID        uuid.NullUUID  `json:"barber_shop_chain_id"`
	Name                     string         `json:"name"`
	ProvinceID               int16          `json:"province_id"`
	DistrictID               int16          `json:"district_id"`
	WardID                   int16          `json:"ward_id"`
	SpecificLocation         string         `json:"specific_location"`
	Phone                    string         `json:"phone"`
	Email                    string         `json:"email"`
	WebsiteUrl               sql.NullString `json:"website_url"`
	AvatarUrl                string         `json:"avatar_url"`
	CoverPhotoUrl            string         `json:"cover_photo_url"`
	FacadePhotoUrl           string         `json:"facade_photo_url"`
	RepresentativeName       string         `json:"representative_name"`
	CitizenID                string         `json:"citizen_id"`
	RepresentativePhone      string         `json:"representative_phone"`
	RepresentativeEmail      string         `json:"representative_email"`
	RepresentativePhoneOther sql.NullString `json:"representative_phone_other"`
	StartTimeMonday          pgtype.Time    `json:"start_time_monday"`
	EndTimeMonday            pgtype.Time    `json:"end_time_monday"`
	StartTimeTuesday         pgtype.Time    `json:"start_time_tuesday"`
	EndTimeTuesday           pgtype.Time    `json:"end_time_tuesday"`
	StartTimeWednesday       pgtype.Time    `json:"start_time_wednesday"`
	EndTimeWednesday         pgtype.Time    `json:"end_time_wednesday"`
	StartTimeThursday        pgtype.Time    `json:"start_time_thursday"`
	EndTimeThursday          pgtype.Time    `json:"end_time_thursday"`
	StartTimeFriday          pgtype.Time    `json:"start_time_friday"`
	EndTimeFriday            pgtype.Time    `json:"end_time_friday"`
	StartTimeSaturday        pgtype.Time    `json:"start_time_saturday"`
	EndTimeSaturday          pgtype.Time    `json:"end_time_saturday"`
	StartTimeSunday          pgtype.Time    `json:"start_time_sunday"`
	EndTimeSunday            pgtype.Time    `json:"end_time_sunday"`
	IntervalScheduler        int16          `json:"interval_scheduler"`
	Longitude                float64        `json:"longitude"`
	Latitude                 float64        `json:"latitude"`
}

func (q *Queries) InsertBarberShop(ctx context.Context, arg InsertBarberShopParams) (BarberShop, error) {
	row := q.db.QueryRow(ctx, insertBarberShop,
		arg.BarberShopChainID,
		arg.Name,
		arg.ProvinceID,
		arg.DistrictID,
		arg.WardID,
		arg.SpecificLocation,
		arg.Phone,
		arg.Email,
		arg.WebsiteUrl,
		arg.AvatarUrl,
		arg.CoverPhotoUrl,
		arg.FacadePhotoUrl,
		arg.RepresentativeName,
		arg.CitizenID,
		arg.RepresentativePhone,
		arg.RepresentativeEmail,
		arg.RepresentativePhoneOther,
		arg.StartTimeMonday,
		arg.EndTimeMonday,
		arg.StartTimeTuesday,
		arg.EndTimeTuesday,
		arg.StartTimeWednesday,
		arg.EndTimeWednesday,
		arg.StartTimeThursday,
		arg.EndTimeThursday,
		arg.StartTimeFriday,
		arg.EndTimeFriday,
		arg.StartTimeSaturday,
		arg.EndTimeSaturday,
		arg.StartTimeSunday,
		arg.EndTimeSunday,
		arg.IntervalScheduler,
		arg.Longitude,
		arg.Latitude,
	)
	var i BarberShop
	err := row.Scan(
		&i.ID,
		&i.BarberShopChainID,
		&i.Name,
		&i.ProvinceID,
		&i.DistrictID,
		&i.WardID,
		&i.SpecificLocation,
		&i.Phone,
		&i.Email,
		&i.WebsiteUrl,
		&i.Coordinates,
		&i.AvatarUrl,
		&i.CoverPhotoUrl,
		&i.FacadePhotoUrl,
		&i.RepresentativeName,
		&i.CitizenID,
		&i.RepresentativePhone,
		&i.RepresentativeEmail,
		&i.RepresentativePhoneOther,
		&i.StartTimeMonday,
		&i.EndTimeMonday,
		&i.StartTimeTuesday,
		&i.EndTimeTuesday,
		&i.StartTimeWednesday,
		&i.EndTimeWednesday,
		&i.StartTimeThursday,
		&i.EndTimeThursday,
		&i.StartTimeFriday,
		&i.EndTimeFriday,
		&i.StartTimeSaturday,
		&i.EndTimeSaturday,
		&i.StartTimeSunday,
		&i.EndTimeSunday,
		&i.IntervalScheduler,
		&i.IsMainBranch,
		&i.IsReputation,
		&i.IsVerified,
		&i.CreateAt,
	)
	return i, err
}

const listBarberShopsByBarberId = `-- name: ListBarberShopsByBarberId :many
SELECT DISTINCT 
    bs.id,
    bs.name,
    bs.specific_location,
    bs.phone,
    bs.email,
    bs.website_url,
    bs.avatar_url,
    bs.cover_photo_url,
    bs.facade_photo_url,
    bs.is_main_branch,
    bs.is_reputation,
    bs.province_name,
    bs.district_name,
    bs.ward_name,
    br.role_id AS role_id
FROM "view_barber_shops" bs
LEFT JOIN "BarberRoles" br ON bs."id" = br."barber_shop_id"
WHERE br."barber_id" = $1
`

type ListBarberShopsByBarberIdRow struct {
	ID               uuid.UUID      `json:"id"`
	Name             string         `json:"name"`
	SpecificLocation string         `json:"specific_location"`
	Phone            string         `json:"phone"`
	Email            string         `json:"email"`
	WebsiteUrl       sql.NullString `json:"website_url"`
	AvatarUrl        string         `json:"avatar_url"`
	CoverPhotoUrl    string         `json:"cover_photo_url"`
	FacadePhotoUrl   string         `json:"facade_photo_url"`
	IsMainBranch     bool           `json:"is_main_branch"`
	IsReputation     bool           `json:"is_reputation"`
	ProvinceName     string         `json:"province_name"`
	DistrictName     string         `json:"district_name"`
	WardName         string         `json:"ward_name"`
	RoleID           pgtype.Int2    `json:"role_id"`
}

func (q *Queries) ListBarberShopsByBarberId(ctx context.Context, barberID uuid.UUID) ([]ListBarberShopsByBarberIdRow, error) {
	rows, err := q.db.Query(ctx, listBarberShopsByBarberId, barberID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBarberShopsByBarberIdRow{}
	for rows.Next() {
		var i ListBarberShopsByBarberIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.SpecificLocation,
			&i.Phone,
			&i.Email,
			&i.WebsiteUrl,
			&i.AvatarUrl,
			&i.CoverPhotoUrl,
			&i.FacadePhotoUrl,
			&i.IsMainBranch,
			&i.IsReputation,
			&i.ProvinceName,
			&i.DistrictName,
			&i.WardName,
			&i.RoleID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNearbyBarberShops = `-- name: ListNearbyBarberShops :many
SELECT
    id,
    barber_shop_chain_id,
    name,
    coordinates,
    "is_reputation",
    CAST(ST_X(ST_GeomFromWKB(coordinates::geometry)) AS float8) AS longitude,
    CAST(ST_Y(ST_GeomFromWKB(coordinates::geometry)) AS float8) AS latitude,
    CAST(ST_Distance(
        ST_SetSRID(ST_MakePoint($2::float, $3::float), 4326),
        coordinates::geography
    ) AS float) AS distance
FROM "BarberShops"
WHERE ST_Distance(coordinates, ST_SetSRID(ST_MakePoint($2::float, $3::float), 4326)) <= $1::int
ORDER BY ST_Distance(coordinates, ST_SetSRID(ST_MakePoint($2::float, $3::float), 4326))
`

type ListNearbyBarberShopsParams struct {
	Column1 int32   `json:"column_1"`
	Column2 float64 `json:"column_2"`
	Column3 float64 `json:"column_3"`
}

type ListNearbyBarberShopsRow struct {
	ID                uuid.UUID     `json:"id"`
	BarberShopChainID uuid.NullUUID `json:"barber_shop_chain_id"`
	Name              string        `json:"name"`
	Coordinates       string        `json:"coordinates"`
	IsReputation      bool          `json:"is_reputation"`
	Longitude         float64       `json:"longitude"`
	Latitude          float64       `json:"latitude"`
	Distance          float64       `json:"distance"`
}

func (q *Queries) ListNearbyBarberShops(ctx context.Context, arg ListNearbyBarberShopsParams) ([]ListNearbyBarberShopsRow, error) {
	rows, err := q.db.Query(ctx, listNearbyBarberShops, arg.Column1, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListNearbyBarberShopsRow{}
	for rows.Next() {
		var i ListNearbyBarberShopsRow
		if err := rows.Scan(
			&i.ID,
			&i.BarberShopChainID,
			&i.Name,
			&i.Coordinates,
			&i.IsReputation,
			&i.Longitude,
			&i.Latitude,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBarberShopsByName = `-- name: SearchBarberShopsByName :many
SELECT
    bs.id,
    bs.barber_shop_chain_id,
    bs.name,
    bs.coordinates,
    bs."is_reputation",
    CAST(ST_X(ST_GeomFromWKB(bs.coordinates::geometry)) AS float8) AS longitude,
    CAST(ST_Y(ST_GeomFromWKB(bs.coordinates::geometry)) AS float8) AS latitude,
    CAST(ST_Distance(
        ST_SetSRID(ST_MakePoint($2::float, $3::float), 4326),
        bs.coordinates::geography
    ) AS float) AS distance
FROM "BarberShops" bs
JOIN "BarberShopChains" bsc ON bs.barber_shop_chain_id = bsc.id
WHERE bsc."name" = $1
ORDER BY ST_Distance(bs.coordinates, ST_SetSRID(ST_MakePoint($2::float, $3::float), 4326))
`

type SearchBarberShopsByNameParams struct {
	Name    string  `json:"name"`
	Column2 float64 `json:"column_2"`
	Column3 float64 `json:"column_3"`
}

type SearchBarberShopsByNameRow struct {
	ID                uuid.UUID     `json:"id"`
	BarberShopChainID uuid.NullUUID `json:"barber_shop_chain_id"`
	Name              string        `json:"name"`
	Coordinates       string        `json:"coordinates"`
	IsReputation      bool          `json:"is_reputation"`
	Longitude         float64       `json:"longitude"`
	Latitude          float64       `json:"latitude"`
	Distance          float64       `json:"distance"`
}

func (q *Queries) SearchBarberShopsByName(ctx context.Context, arg SearchBarberShopsByNameParams) ([]SearchBarberShopsByNameRow, error) {
	rows, err := q.db.Query(ctx, searchBarberShopsByName, arg.Name, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchBarberShopsByNameRow{}
	for rows.Next() {
		var i SearchBarberShopsByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.BarberShopChainID,
			&i.Name,
			&i.Coordinates,
			&i.IsReputation,
			&i.Longitude,
			&i.Latitude,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBarberShopById = `-- name: UpdateBarberShopById :one
UPDATE "BarberShops"
SET 
    name = COALESCE($6, name),
    is_main_branch = COALESCE($2, is_main_branch),
    coordinates = COALESCE(ST_GeographyFromText('POINT(' || $7::float8 || ' ' || $8::float8 || ')'), coordinates),
    interval_scheduler = COALESCE($3, interval_scheduler),
    is_reputation = COALESCE($4, is_reputation),
    is_verified = COALESCE($5, is_verified),
    update_at = now()
WHERE "id" = $1
RETURNING id, barber_shop_chain_id, name, province_id, district_id, ward_id, specific_location, phone, email, website_url, coordinates, avatar_url, cover_photo_url, facade_photo_url, representative_name, citizen_id, representative_phone, representative_email, representative_phone_other, start_time_monday, end_time_monday, start_time_tuesday, end_time_tuesday, start_time_wednesday, end_time_wednesday, start_time_thursday, end_time_thursday, start_time_friday, end_time_friday, start_time_saturday, end_time_saturday, start_time_sunday, end_time_sunday, interval_scheduler, is_main_branch, is_reputation, is_verified, create_at
`

type UpdateBarberShopByIdParams struct {
	ID                uuid.UUID      `json:"id"`
	IsMainBranch      bool           `json:"is_main_branch"`
	IntervalScheduler int16          `json:"interval_scheduler"`
	IsReputation      bool           `json:"is_reputation"`
	IsVerified        bool           `json:"is_verified"`
	Name              sql.NullString `json:"name"`
	Longitude         pgtype.Float8  `json:"longitude"`
	Latitude          pgtype.Float8  `json:"latitude"`
}

func (q *Queries) UpdateBarberShopById(ctx context.Context, arg UpdateBarberShopByIdParams) (BarberShop, error) {
	row := q.db.QueryRow(ctx, updateBarberShopById,
		arg.ID,
		arg.IsMainBranch,
		arg.IntervalScheduler,
		arg.IsReputation,
		arg.IsVerified,
		arg.Name,
		arg.Longitude,
		arg.Latitude,
	)
	var i BarberShop
	err := row.Scan(
		&i.ID,
		&i.BarberShopChainID,
		&i.Name,
		&i.ProvinceID,
		&i.DistrictID,
		&i.WardID,
		&i.SpecificLocation,
		&i.Phone,
		&i.Email,
		&i.WebsiteUrl,
		&i.Coordinates,
		&i.AvatarUrl,
		&i.CoverPhotoUrl,
		&i.FacadePhotoUrl,
		&i.RepresentativeName,
		&i.CitizenID,
		&i.RepresentativePhone,
		&i.RepresentativeEmail,
		&i.RepresentativePhoneOther,
		&i.StartTimeMonday,
		&i.EndTimeMonday,
		&i.StartTimeTuesday,
		&i.EndTimeTuesday,
		&i.StartTimeWednesday,
		&i.EndTimeWednesday,
		&i.StartTimeThursday,
		&i.EndTimeThursday,
		&i.StartTimeFriday,
		&i.EndTimeFriday,
		&i.StartTimeSaturday,
		&i.EndTimeSaturday,
		&i.StartTimeSunday,
		&i.EndTimeSunday,
		&i.IntervalScheduler,
		&i.IsMainBranch,
		&i.IsReputation,
		&i.IsVerified,
		&i.CreateAt,
	)
	return i, err
}
