// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: barber_shops.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
)

const createBarberShop = `-- name: CreateBarberShop :one
INSERT INTO "BarberShops" (
                           barbershop_chain_id,
                           name,
                           is_main_branch,
                           branch_count,
                           coordinates,
                           address,
                           image
                           )
VALUES (
        $1,
        $2,
        $3,
        $4,
        ST_GeographyFromText('POINT(' || $5::float8 || ' ' || $6::float8 || ')'),
        $7,
        $8
        ) RETURNING id, barbershop_chain_id, name, is_main_branch, branch_count, coordinates, address, image, status, rate, start_time, end_time, break_time, break_minutes, interval_scheduler, reputation, create_at, update_at
`

type CreateBarberShopParams struct {
	BarbershopChainID uuid.NullUUID  `json:"barbershop_chain_id"`
	Name              string         `json:"name"`
	IsMainBranch      sql.NullBool   `json:"is_main_branch"`
	BranchCount       int32          `json:"branch_count"`
	Longitude         float64        `json:"longitude"`
	Latitude          float64        `json:"latitude"`
	Address           string         `json:"address"`
	Image             sql.NullString `json:"image"`
}

func (q *Queries) CreateBarberShop(ctx context.Context, arg CreateBarberShopParams) (BarberShop, error) {
	row := q.db.QueryRowContext(ctx, createBarberShop,
		arg.BarbershopChainID,
		arg.Name,
		arg.IsMainBranch,
		arg.BranchCount,
		arg.Longitude,
		arg.Latitude,
		arg.Address,
		arg.Image,
	)
	var i BarberShop
	err := row.Scan(
		&i.ID,
		&i.BarbershopChainID,
		&i.Name,
		&i.IsMainBranch,
		&i.BranchCount,
		&i.Coordinates,
		&i.Address,
		&i.Image,
		&i.Status,
		&i.Rate,
		&i.StartTime,
		&i.EndTime,
		&i.BreakTime,
		&i.BreakMinutes,
		&i.IntervalScheduler,
		&i.Reputation,
		&i.CreateAt,
		&i.UpdateAt,
	)
	return i, err
}

const deleteBarberShops = `-- name: DeleteBarberShops :exec
DELETE FROM "BarberShops"
WHERE id = $1
`

func (q *Queries) DeleteBarberShops(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteBarberShops, id)
	return err
}

const getBarberShop = `-- name: GetBarberShop :one
SELECT id, barbershop_chain_id, name, is_main_branch, branch_count, coordinates, address, image, status, rate, start_time, end_time, break_time, break_minutes, interval_scheduler, reputation, create_at, update_at
FROM "BarberShops"
WHERE id = $1
`

func (q *Queries) GetBarberShop(ctx context.Context, id uuid.UUID) (BarberShop, error) {
	row := q.db.QueryRowContext(ctx, getBarberShop, id)
	var i BarberShop
	err := row.Scan(
		&i.ID,
		&i.BarbershopChainID,
		&i.Name,
		&i.IsMainBranch,
		&i.BranchCount,
		&i.Coordinates,
		&i.Address,
		&i.Image,
		&i.Status,
		&i.Rate,
		&i.StartTime,
		&i.EndTime,
		&i.BreakTime,
		&i.BreakMinutes,
		&i.IntervalScheduler,
		&i.Reputation,
		&i.CreateAt,
		&i.UpdateAt,
	)
	return i, err
}

const listBarberShopsNearby = `-- name: ListBarberShopsNearby :many
SELECT
    id,
    barbershop_chain_id,
    name,
    branch_count,
    coordinates,
    address,
    image,
    status,
    rate,
    "reputation",
    CAST(ST_X(ST_GeomFromWKB(coordinates::geometry)) AS float8) AS longitude,
    CAST(ST_Y(ST_GeomFromWKB(coordinates::geometry)) AS float8) AS latitude,
    CAST(ST_Distance(
        ST_SetSRID(ST_MakePoint($1::float, $2::float), 4326),
        coordinates::geography
    ) AS float) AS distance
FROM "BarberShops"
WHERE  ST_Distance(coordinates, ST_SetSRID(ST_MakePoint($1::float, $2::float), 4326)) <= $3::int
ORDER BY ST_Distance(coordinates, ST_SetSRID(ST_MakePoint($1::float, $2::float), 4326))
`

type ListBarberShopsNearbyParams struct {
	CurrentLongitude float64 `json:"current_longitude"`
	CurrentLatitude  float64 `json:"current_latitude"`
	DistanceInMeters int32   `json:"distance_in_meters"`
}

type ListBarberShopsNearbyRow struct {
	ID                uuid.UUID      `json:"id"`
	BarbershopChainID uuid.NullUUID  `json:"barbershop_chain_id"`
	Name              string         `json:"name"`
	BranchCount       int32          `json:"branch_count"`
	Coordinates       string         `json:"coordinates"`
	Address           string         `json:"address"`
	Image             sql.NullString `json:"image"`
	Status            int32          `json:"status"`
	Rate              float64        `json:"rate"`
	Reputation        bool           `json:"reputation"`
	Longitude         float64        `json:"longitude"`
	Latitude          float64        `json:"latitude"`
	Distance          float64        `json:"distance"`
}

func (q *Queries) ListBarberShopsNearby(ctx context.Context, arg ListBarberShopsNearbyParams) ([]ListBarberShopsNearbyRow, error) {
	rows, err := q.db.QueryContext(ctx, listBarberShopsNearby, arg.CurrentLongitude, arg.CurrentLatitude, arg.DistanceInMeters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBarberShopsNearbyRow{}
	for rows.Next() {
		var i ListBarberShopsNearbyRow
		if err := rows.Scan(
			&i.ID,
			&i.BarbershopChainID,
			&i.Name,
			&i.BranchCount,
			&i.Coordinates,
			&i.Address,
			&i.Image,
			&i.Status,
			&i.Rate,
			&i.Reputation,
			&i.Longitude,
			&i.Latitude,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryBarberShops = `-- name: QueryBarberShops :many
SELECT bs.id, bs.barbershop_chain_id, bs.name, bs.is_main_branch, bs.branch_count, bs.coordinates, bs.address, bs.image, bs.status, bs.rate, bs.start_time, bs.end_time, bs.break_time, bs.break_minutes, bs.interval_scheduler, bs.reputation, bs.create_at, bs.update_at
FROM "BarberShops" bs
WHERE bs."name" = $1
  OR bs."barbershop_chain_id" IN (
    SELECT c."barbershop_chain_id"
    FROM "BarberShopChains" c
    WHERE c."name" = $1
)
`

func (q *Queries) QueryBarberShops(ctx context.Context, name string) ([]BarberShop, error) {
	rows, err := q.db.QueryContext(ctx, queryBarberShops, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BarberShop{}
	for rows.Next() {
		var i BarberShop
		if err := rows.Scan(
			&i.ID,
			&i.BarbershopChainID,
			&i.Name,
			&i.IsMainBranch,
			&i.BranchCount,
			&i.Coordinates,
			&i.Address,
			&i.Image,
			&i.Status,
			&i.Rate,
			&i.StartTime,
			&i.EndTime,
			&i.BreakTime,
			&i.BreakMinutes,
			&i.IntervalScheduler,
			&i.Reputation,
			&i.CreateAt,
			&i.UpdateAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBarberShop = `-- name: UpdateBarberShop :one
UPDATE "BarberShops"
SET 
    name = coalesce($2, name),
    is_main_branch = coalesce($3, is_main_branch),
    branch_count = coalesce($4, branch_count),
    coordinates = coalesce(ST_GeographyFromText('POINT(' || $5::float8 || ' ' || $6::float8 || ')'), coordinates),
    address = coalesce($7, address),
    image = coalesce($8, image),
    status = coalesce($9, status),
    rate = coalesce($10, rate),
    start_time = coalesce($11, start_time),
    end_time = coalesce($12, end_time),
    break_time = coalesce($13, break_time),
    interval_scheduler = coalesce($14, interval_scheduler),
    update_at = now()
WHERE "id" = $1
RETURNING id, barbershop_chain_id, name, is_main_branch, branch_count, coordinates, address, image, status, rate, start_time, end_time, break_time, break_minutes, interval_scheduler, reputation, create_at, update_at
`

type UpdateBarberShopParams struct {
	ID                uuid.UUID       `json:"id"`
	Name              sql.NullString  `json:"name"`
	IsMainBranch      sql.NullBool    `json:"is_main_branch"`
	BranchCount       sql.NullInt32   `json:"branch_count"`
	Longitude         sql.NullFloat64 `json:"longitude"`
	Latitude          sql.NullFloat64 `json:"latitude"`
	Address           sql.NullString  `json:"address"`
	Image             sql.NullString  `json:"image"`
	Status            sql.NullInt32   `json:"status"`
	Rate              sql.NullFloat64 `json:"rate"`
	StartTime         pgtype.Time     `json:"start_time"`
	EndTime           pgtype.Time     `json:"end_time"`
	BreakTime         pgtype.Time     `json:"break_time"`
	IntervalScheduler sql.NullInt32   `json:"interval_scheduler"`
}

func (q *Queries) UpdateBarberShop(ctx context.Context, arg UpdateBarberShopParams) (BarberShop, error) {
	row := q.db.QueryRowContext(ctx, updateBarberShop,
		arg.ID,
		arg.Name,
		arg.IsMainBranch,
		arg.BranchCount,
		arg.Longitude,
		arg.Latitude,
		arg.Address,
		arg.Image,
		arg.Status,
		arg.Rate,
		arg.StartTime,
		arg.EndTime,
		arg.BreakTime,
		arg.IntervalScheduler,
	)
	var i BarberShop
	err := row.Scan(
		&i.ID,
		&i.BarbershopChainID,
		&i.Name,
		&i.IsMainBranch,
		&i.BranchCount,
		&i.Coordinates,
		&i.Address,
		&i.Image,
		&i.Status,
		&i.Rate,
		&i.StartTime,
		&i.EndTime,
		&i.BreakTime,
		&i.BreakMinutes,
		&i.IntervalScheduler,
		&i.Reputation,
		&i.CreateAt,
		&i.UpdateAt,
	)
	return i, err
}
