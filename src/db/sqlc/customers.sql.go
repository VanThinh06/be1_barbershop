// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: customers.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO "Customers" (
   "name",
    email,
    phone,
    gender,
    hashed_password,
    is_social_auth
  )
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6::bool
  )
RETURNING customer_id, name, email, phone, gender, hashed_password, avatar, password_changed_at, create_at, update_at, is_social_auth
`

type CreateCustomerParams struct {
	Name           string `json:"name"`
	Email          string `json:"email"`
	Phone          string `json:"phone"`
	Gender         int32  `json:"gender"`
	HashedPassword string `json:"hashed_password"`
	IsSocialAuth   bool   `json:"is_social_auth"`
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRowContext(ctx, createCustomer,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.Gender,
		arg.HashedPassword,
		arg.IsSocialAuth,
	)
	var i Customer
	err := row.Scan(
		&i.CustomerID,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.Gender,
		&i.HashedPassword,
		&i.Avatar,
		&i.PasswordChangedAt,
		&i.CreateAt,
		&i.UpdateAt,
		&i.IsSocialAuth,
	)
	return i, err
}

const getContactCustomer = `-- name: GetContactCustomer :one
SELECT customer_id, name, email, phone, gender, hashed_password, avatar, password_changed_at, create_at, update_at, is_social_auth
FROM "Customers"
WHERE
    (
        ($2::varchar = 'email' AND email = $1)
        OR
        ($2::varchar = 'phone' AND phone = $1)
    )
LIMIT 1
`

type GetContactCustomerParams struct {
	Email        string `json:"email"`
	TypeUsername string `json:"type_username"`
}

func (q *Queries) GetContactCustomer(ctx context.Context, arg GetContactCustomerParams) (Customer, error) {
	row := q.db.QueryRowContext(ctx, getContactCustomer, arg.Email, arg.TypeUsername)
	var i Customer
	err := row.Scan(
		&i.CustomerID,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.Gender,
		&i.HashedPassword,
		&i.Avatar,
		&i.PasswordChangedAt,
		&i.CreateAt,
		&i.UpdateAt,
		&i.IsSocialAuth,
	)
	return i, err
}

const updateCustomer = `-- name: UpdateCustomer :one
UPDATE "Customers"
set name = coalesce($1, name),
  email = coalesce($2, email),
  phone = coalesce($3, phone),
  gender = coalesce($4, gender),
  avatar = coalesce($5, avatar),
  "hashed_password" = coalesce($6, hashed_password),
  "password_changed_at" = coalesce(
    $7,
    password_changed_at
  ),
  "update_at" = $8
  WHERE "customer_id" = $9
RETURNING customer_id, name, email, phone, gender, hashed_password, avatar, password_changed_at, create_at, update_at, is_social_auth
`

type UpdateCustomerParams struct {
	Name              sql.NullString `json:"name"`
	Email             sql.NullString `json:"email"`
	Phone             sql.NullString `json:"phone"`
	Gender            sql.NullInt32  `json:"gender"`
	Avatar            sql.NullString `json:"avatar"`
	HashedPassword    sql.NullString `json:"hashed_password"`
	PasswordChangedAt sql.NullTime   `json:"password_changed_at"`
	UpdateAt          sql.NullTime   `json:"update_at"`
	CustomerID        uuid.UUID      `json:"customer_id"`
}

func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) (Customer, error) {
	row := q.db.QueryRowContext(ctx, updateCustomer,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.Gender,
		arg.Avatar,
		arg.HashedPassword,
		arg.PasswordChangedAt,
		arg.UpdateAt,
		arg.CustomerID,
	)
	var i Customer
	err := row.Scan(
		&i.CustomerID,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.Gender,
		&i.HashedPassword,
		&i.Avatar,
		&i.PasswordChangedAt,
		&i.CreateAt,
		&i.UpdateAt,
		&i.IsSocialAuth,
	)
	return i, err
}
